/**

\page exampleclientpage Example client code

The following example applications are provided:
- sendcommand:
  A simple application that connects to a receiver, and sends a single command.
  The method of connection (serial or tcp), the serial port or host name and
  connection settings, as well as the command to be sent must be given as
  command-line arguments.
  Invoke sendcommand without arguments to get more information on how to invoke
  sendcommand.
- console:
  A simple application that connects to a receiver and displays information about
  the data being received from and sent to the receiver. The user can choose
  to display this information on the text console, and/or in a GUI window.
  The latter also makes it possible to enter and send ASCII commands to the receiver.

The source code for these applications can be found in the examples folder.

\section exampleclientpage_interacting Interaction with a receiver

All interaction with a receiver is realized using an instance of the \link SSN::SsnRx SsnRx class\endlink.

On one hand this class defines methods to connect to a receiver (using a serial port or over TCP/IP), and to send ASCII commands to the connected receiver.

On the other hand, this class defines a collection of <i>signals</i>, each of which are emitted when a particular state
change occurs in the SsnRx object, e.g. when an SBF block is received.

Refer to the documentation of \link SSN::SsnRx SsnRx class\endlink for the full list of signals and methods.

Hooking up client code to respond to the relevant state changes or receival of data happens by
connecting so-called slots to the appropriate signals of SsnRx.
(For more details on the signal/slot mechanism, see http://qt-project.org/doc/signalsandslots.html)

In its current state, it is required that the application enters a so-called event loop, in which the SsnRx instance
can handle the communication with the receiver. SsnRx is currently restricted to be used only in the main application thread.

At a very high level of abstraction, the client code contains the following ingredients:

\code
#include "ssnrx.h"

QApplication app(argc, argv);
...
SSN::SsnRx* rx = new SSN::SsnRx();
...
if (!rx->connectSerial(serialPortName, serialPortSettings))
{
  qFatal("Cannot open serial port %s. Exiting..", qPrintable(serialPortName));
}
...
connect(rx,SIGNAL(newSBFBlock(const QByteArray&)), targetObject, SLOT(processSBF(const QByteArray&)));
...
// enter event loop
app.exec();
\endcode


In the future, SsnRx will be improved so that it can be used in a multi-threaded context.
Likewise, it will become possible to use SsnRx without entering a main event loop.

\section exampleclientpage_noteonsbf Note when using sbf.h

The example applications included in this SDK do not parse the specific contents
of the SBF blocks. For an example of how to do this, refer to the sbf2asc sample
code that is available as part of the RxTools suite. That sample code includes
sbfdef.h, a C header file facilitating the parsing of SBF blocks.

Note that when using sbfdef.h to interpret SBF blocks, your application
must be compiled with 4-byte variable alignmnent. This can be enforced
by including the following in your .pro files:

<code>
win32{
  QMAKE_CFLAGS += -Zp4
  QMAKE_CXXFLAGS += -Zp4
}
unix{
  QMAKE_CFLAGS += -mno-align-double
  QMAKE_CXXFLAGS += -mno-align-double
}
</code>

*/
